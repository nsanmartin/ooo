* Programming As Theory Building

+ ¿Cómo relacionaría lo escrito por Naur con un sistema de
  organización a de trabajo como el Taylorismo?

El escrito de Naur propone una concepción de la actividad del
programador como una "construcción de teoría" (theory building). Esta
noción de teoría está basada en la de Ryle, la cual está basada en el
análisis de la naturaleza de la actividad intelectual (y en particular
en cuanto difiere de la mera inteligencia (merely inttelligent). Esta
tería es el conocimiento que permite al programador explicar cómo su
solución  se relaciona a los aspectos del mundo que ayuda a manejar,
explicar porqué las partes de su programa se decomponene del modo en
que lo hacen, responder a las necesidades de modificación en el
programa a medida que se torna necesario.

Esto se relaciona con su noción de "vida" de un programa. Según Naur,
entonces, la construcción de un programa es la construcción de una
teoría del mismo por parte de un equipo. La vida de un programa es
correlativa a la existencia del mismo, sin el cual el mismo se
considera muerto. Esto implica que, por ejemplo, la inclusión de un
nuevo miembro al equipo requiere que el mismo tenga la oportunidad de
mantener un contacto cercano con aquellos programadores que ya conocen
la teoría vinculada al mismo, de forma de poder volverse familiar con
la misma (y copara la educación de un programador que se incluye
a un proyecto con actividades artísticas).

Como conlusión podemos decir que, entendiéndo la programación como
construcción de teoría, no puede ser reducida a una mera secuenciación
de instrucciones como en el caso de los métodos industriales
tayloristas. En particular, el programador no puede ser considerado
como un componente facilmente reemplazable, dado el papel fundamental
del desarrollo de la teoría vinculada a su actividad.

+ ¿Qué habría que modificar en la concepción de Naur para que esta sea
  compatible con la visión de que la programación puede ser en el
  futuro desarrollada por completo por agentes artificiales?

Si por "agentes artificiales" entendemos meros autómatas que ejecutan
una seria de instrucciones fijas, desde luego que esto no es
compatible con la concepción de Naur. Para que fuera compatible
debería prescindirse de la importancia de la teoría sobre su actividad
de parte del programados, dado que una agente así sería incapaz tanto
de comprender el programa como su relación con el problema que está
llamado a resolver, y asimismo sería incapaz de responder
adecuadamente a las demandas de modificaciones que son inevitables en
todo proyecto. Es decir, la concepción debería reemplazarse por una
que tomara la programación como mera aplicación de reglas y el
seguimeinto de instrucciones.

* The Design of Everyday Things
+ Elija dos entes de la realidad (pueden ser objetos físicos del mundo
  real o incluso software) y clasifíquelos por: Visibilidad de las
  partes a operar, Visibilidad de Mapeo, Feedback, Modelo Conceptual y
  Diseño Natural (y sus affordances). Por ej. hablando de Modelo
  Conceptual, una tijera tiene uno bueno, un reloj digital uno
  inexistente, y la heladera con freezer de Dan uno malo. Explique y
  justifique cada una de las 5 apreciaciones de la clasificación. No
  puede utilizar ninguno de los ejemplos dados en el libro o los
  videos de Norman.

Cocina: las partes a operar son cada una de las perillas con las que
se contraola la intensidad de la llama de cada hornalla y del horno, y
la que controla la chispa (para encender), además de uan manija para
abrir la puerta del horno. Las partes son bien visibles y se
encuentran en un lugar esperable (es estándar). Además, cada perilla
tiene un pequeño esquema donde se puede ver a qué horanalla
corresponde facilmente, para hacer el mapeo más visible. El mapeo de
la manija para abrir el horno es natural (similar al del agujero de la
tijera). El feedback está provisto por la intensidad de la llama y es
por ende inmediato. El modelo conceptual puede considerarse bueno, ya
que cada control actúa de modo independiente y el resultado de operar
en ellos es completamente predecible. El diseño resulta natural, ya
que las perillas naturalmente son usadas para ajustar una magnitud (la
llama) la manija de la puerta del horno, para tirar y abrirla. Y por
su puesto, las hornallas para apoyar lso elementos de cocina, así como
el interior del horno.

Agujereadora: La visibilidad de las partes es adecuada: su forma
indica el modo en que debe ser agarrada y la función del gatillo
resulta clara. El mapeo con su función es también inequívoca. El
feedback es bueno, dado que la mecha empieza a girar ni bien se apreta
el gatillo, lo cual hace a un buen modelo conceptual y un diseño natural. 

* Design Principles Behind Smalltalk
+ ¿Qué modalidad usaron los desarrolladores del proyecto Smalltalk?
  La modalidad usada es descripta por el autor como un ciclo
  (iterativo) de cuatro  años comparable con el método científico. El
  ciclo incluía tres partes: construir una aplicación en el marco del
  sistema (homólogo a realizar una observación en el método
  científico); basándose en esa experiencia, rediseñar el lenguaje
  (formular una teoría), y construir un nuevo sistema basado en ese
  rediseño (relizar una predicción que sea contrastble).
+ ¿En qué dos aspectos decidieron enfocarse para investigar?
  Los aspectos en que se enfocaron fueron: un lenguaje de descripción
  (lemguaje de programación) que sirva como interfaz entre los modelos
  en la mente humana y los modelos en el hardware y un lenguaje de
  interacción (interfaz de ususario) que vincule el systema de
  comunicación humano con el de la computadora.
+ El paper enumera rápidamente dos principios en los que se basa el
  diseño de Smalltalk. ¿Cuál es el tercero y que significa?  EL tercer
  principio del diseño es que el cómputo debe ser visto como una
  competencia intrínseca capaz de ser invocada uniformamente mediante
  el envío de mensajes. Este principio implica que, por ejemplo para
  realizar una operación sobre un número como la suma, se envía un
  mensaje conteniendo su nombre y los argumentos (colaboradores)
  necesarios al número, y que es quien recibe este mensaje quien mejor
  sabe cómo llevar a cabo la operación requerida. Esta solución
  resulta limpia, dado que no se requiere saber sobre la
  implementación de la operación (y en general, la forma en que debe
  un objeto responder a un mensaje) desde afuera del objeto que lo recibe.
